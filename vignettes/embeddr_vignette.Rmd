---
title: "Using embeddr for pseudotemporal ordering of single-cell gene expression"
author: "Kieran Campbell"
date: "March 2015"
output:
  html_document:
    fig_height: 3.8
    fig_width: 5
    fig_align: 'center'
---

Here we show how `embeddr` (= spectral embedding + principal curves) can be used for pseudotemporal ordering of single-cell gene expression data using the [monocle](http://cole-trapnell-lab.github.io/monocle-release/) dataset.

```{r load-all, message=FALSE, warning=FALSE}
library(monocle)
library(devtools)
load_all('..')
data(HSMM)
```

First we go through cleaning the monocle dataset and selecting for marker genes only:

```{r clean-monocle, cache=TRUE}
marker_genes <- row.names(subset(fData(HSMM),
                                 gene_short_name %in% c("MEF2C", "MEF2D", "MYF5", "ANPEP", "PDGFRA",
                  "MYOG", "TPM1", "TPM2", "MYH2", "MYH3", "NCAM1",
                  "CDK1", "CDK2", "CCNB1", "CCNB2", "CCND1", "CCNA")))
x <- log(exprs(HSMM[marker_genes,]) + 1)
x <- t(scale(t(x)))
dim(x)
```

Laplacian eigenmaps require the specification of a nearest-neighbor graph. We can do this using `embeddr::weighted_graph()` using the default options of 20 nearest neighbours. Other options for creating the graph (such as distance measures and heat kernels) are also available.

```{r create-graph, cache=TRUE}
W <- weighted_graph(x)
```

Then we can use `embeddr::laplacian_eigenmap` for the dimensionality reduction. By default this uses the normalized graph laplacian, though the unnormalised laplacian can also be used (see here for details).

```{r laplacian-eigenmap, cache=TRUE, fig.align='center'}
M <- laplacian_eigenmap(W)
plot_embedding(M)
```

The function `embeddr::plot_embedding` can be used at any time on the appropriate `data.frame` objects and will display all relevant information. We can start by seeing where the different inferred states from the monocle dataset fall on our embedding:

```{r monocle-state, fig.align='center', cache=TRUE}
HSMM <- setOrderingFilter(HSMM, marker_genes)
HSMM <- reduceDimension(HSMM, use_irlba = F)
HSMM <- orderCells(HSMM, num_paths=2, reverse=F)
M$monocle_state <- pData(HSMM)$State
plot_embedding(M, color_by = 'monocle_state')
```

So there appears to be reasonable correspondance between the monocle clusters and natural clusters in our data. The `embeddr::cluster_embedding` function applies k-means clustering to the dataset:

```{r cluster-embedding, fig.align='center', cache=TRUE, message=FALSE}
M <- cluster_embedding(M, k=3)
plot_embedding(M)
```

In the `monocle` paper they show that groups 2 & 3 correspond to differentiating cells while group 1 is contamination. We can separate off groups 2 & 3, fit the pseudotime trajectories and plot:

```{r fit-pseudotime, fig.align='center', cache=TRUE}
Mp <- fit_pseudotime(M, clusters=c(2,3))
plot_embedding(Mp)
```
