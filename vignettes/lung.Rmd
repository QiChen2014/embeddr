---
title: "Pseudotemporal ordering of cells from the distal lung epithelium"
author: "Kieran Campbell"
date: "03/24/2015"
output: 
  html_document:
    fig_align: center
    toc: yes
---

Initial data processing: first we read in the data and remove bulk transcripts:

```{r load-lib, message=FALSE}
library(dplyr)
library(devtools)
library(data.table)
library(ggplot2)
library(splines)
library(VGAM)
library(corrplot)
library(scater)
library(biomaRt)
library(org.Mm.eg.db)
library(goseq)
embeddr_path <-  "/net/isi-scratch/kieran/embeddr/embeddr" # '~/oxford/embeddr/embeddr' #
load_all(embeddr_path)

set.seed(123)
```

```{r load-data, cache=TRUE}
## load object 'sce' 
load('/net/isi-scratch/kieran/embeddr/embeddr/data/lung_sce.RData.gz')
sce@lowerDetectionLimit <- 0 # from paper
```

Next we want to fit a noise model to find highly variable genes:
```{r noise-model, cache=TRUE, fig.align='center'}
Lmeans <- rowMeans(exprs(sce))
Lvars <- apply(exprs(sce), 1, var)

to_use <- Lmeans > 0.5 & Lvars > 0 

LCV <- Lvars[to_use] / Lmeans[to_use]^2

df_var <- data.frame(CV2 = LCV, m=Lmeans[to_use])

fit_loglin <- nls(CV2 ~ a + b / m, data = df_var, start=c(a=80, b=5)) 

f <- function(x) coef(fit_loglin)[1] + coef(fit_loglin)[2] / x

is_het <- LCV > 1.5 * predict(fit_loglin)
df_var$is_het <- is_het

ggplot(df_var, aes(x=m, y=CV2, color=is_het)) + geom_point() +
  stat_function(fun=f, color='black') + theme_bw()

het_genes <- names(which(is_het))
het_indices <- match(het_genes, rownames(sce))

sce_var <- sce[het_indices,]
```

Now we can apply laplacian eigenmaps using a nearest-neighbour graph:

```{r le1, cache=TRUE, fig.align='center', message=FALSE, warning=FALSE}
W <- weighted_graph(sce_var, metric='correlation', nn=10)
sce <- laplacian_eigenmap(sce, W, type='unorm', p = 3)

phenoData(sce)$cluster <- pData(sce)$putative_cell_type
plot_embedding(sce)
plot_graph(sce, W)
```

It is obvious we have two very separate trajectories; let's consider the pseudotemporal ordering of one only:

```{r cluster-plot, cache=TRUE, fig.align='center', message=FALSE}
sce <- cluster_embedding(sce, method='kmeans', k = 4)
plot_embedding(sce)

cl1 <- pData(sce)$cluster %in% 1:3
sce_13 <- sce[,cl1]

sce_13 <- fit_pseudotime(sce_13)

plot_embedding(sce_13)
```

We can also plot genes in pseudotime:

```{r plot-ps, cache=TRUE, fig.align='center'}
plot_in_pseudotime( sce_13['Fabp5',] )
```

It appears cluster 2 corresponds to `BP` cells, while cluster 1 corresponds to `AT1` and cluster 3 corresponds to `AT2` cells. We'd ideally like to have a pseudotemporal ordering ofr cells as they transition from `BP` to `AT1` and a second transitioning from `BP` to `AT2`. Let's start with the first. From visual inspection there also appear to be some outlier cells mis-classified. Let's remove them before continuing also.

```{r ps-1, cache=TRUE, fig.align='center'}
sce_bp_at1 <- sce[, pData(sce)$cluster %in% c(1,3) & pData(sce)$component_1 < -0.045]
sce_bp_at1 <- fit_pseudotime(sce_bp_at1)
sce_bp_at1 <- reverse_pseudotime(sce_bp_at1)
plot_embedding(sce_bp_at1)
```

## Finding genes differentially expressed across pseudotime

### BP to AT1 transition

Now we can plot genes just for this in pseudotime:
```{r remove-zero-var, cache=TRUE}
gene <- 'Fabp5'
plot_in_pseudotime( sce_bp_at1[gene,])

## Remove genes expressed in less than 20% of cells
n_cells_expressed <- rowSums(isExprs(sce_bp_at1))
keep_gene <- n_cells_expressed > 0.2 * dim(sce_bp_at1)[2]
sce_bp_at1 <- sce_bp_at1[keep_gene,]
print(sce_bp_at1)
```

We can also fit a pseudotime cubic smoothing spline regression to `Fabp5`:

```{r plot-fap, cache=TRUE, fig.align='center', fig.width=5.5, fig.height=3.5}
model <- fit_pseudotime_model(sce_bp_at1, gene)
null_model <- fit_null_model(sce_bp_at1,  gene)
p_val <- compare_models(model, null_model)
plot_pseudotime_model(sce_bp_at1[gene,], model) + ggtitle('Fabp5 expression in pseudotime')
print(paste('P-value: ', p_val))
```

We can then perform the same tests across all genes:

```{r vary-sig-at1, cache=TRUE}
sce_bp_at1@lowerDetectionLimit <- 0
diff_gene_test <- pseudotime_test(sce_bp_at1)
```

Plot the p-values:

```{r plot-pval, fig.align='center', cache=TRUE, fig.width=5, fig.height=3.5}
## correct differential gene test
diff_gene_test <- dplyr::filter(diff_gene_test, p_val < 1)
diff_gene_test$q_val <- p.adjust(diff_gene_test$p_val, method='BH')
qplot(diff_gene_test$p_val, binwidth = 0.01) + theme_bw() + xlab('p-value') 
qplot(diff_gene_test$q_val, binwidth = 0.01) + theme_bw() + xlab('corrected p-value')
alpha <- 0.01
sig_genes <- diff_gene_test$gene[diff_gene_test$q_val < alpha]
sce_sig <- sce_bp_at1[sig_genes,]

```

```{r print-at1, fig.align='center', fig.height=6, fig.width=9, cache=TRUE}
plot_pseudotime_model(sce_sig)
```

Plot correlations of genes across pseudotime:
```{r plot-corr, fig.align='center', fig.width=9, fig.height=9, cache=TRUE}
pe <- predicted_expression(sce_sig)
```

Look at directionality of genes by hierarchical clustering:
```{r corr-clust, fig.align='center', cache=TRUE, fig.width=9}
pcor <- cor(pe)
dist_cor <- 1 - pcor / 2 
hc <- hclust(as.dist(dist_cor))
plot(hc)
```

Finally plot genes going up or down in pseudotime:
```{r gene-up, message=FALSE, fig.align='center', cache=TRUE, fig.width=10, fig.height=4}
n_cuts <- 2
gene_classes <- cutree(hc, n_cuts)
      
df_gene <- data.frame(gene=colnames(pe), class=gene_classes)

pe <- data.frame(scale(pe)) ## scaled pst-by-gene
pe$pseudotime <- pseudotime(sce_sig)
## save(pe, df_gene, file='~/pe.Rdata')

pe_melted <- melt(pe, id.vars='pseudotime', value.name='expression', variable.name='gene')
pe_melted <- inner_join(pe_melted, df_gene)

## we want to plot the mean expression rather than all of it (messy)
gp_groups <- group_by(pe_melted, class, pseudotime)
mean_expr_per_group <- dplyr::summarise(gp_groups, mean_expr = mean(expression))
pe_melted <- inner_join(pe_melted, mean_expr_per_group)
## pe_melted <- arrange(pe_melted, gene, pseudotime)

ggplot(pe_melted) + geom_line(aes(x=pseudotime, y=mean_expr), color='red') +
  facet_wrap(~ class) + stat_density2d(aes(x=pseudotime, y=expression), n=150) +
  theme_bw() + ylab('Expression')

```

Now look at enriched GO terms for each class:

```{r enrich-go, cache=TRUE, message=FALSE, warning=FALSE}
gene_names <- df_gene$gene

genes_per_class <- sapply(1:n_cuts, function(i) 1 * (df_gene$class == i))
rownames(genes_per_class) <- gene_names
# all_other_genes <- setdiff(featureNames(sce_bp_at1), gene_names)
# zero_matrix <- matrix(0, nrow=length(all_other_genes), ncol=n_cuts, dimnames=list(all_other_genes))
# genes_per_class <- rbind(genes_per_class, zero_matrix)
genes_per_class <- as.data.frame(genes_per_class)

ensembl_mouse <- useMart("ensembl",dataset="mmusculus_gene_ensembl")
ids <- getBM(attributes=c('mgi_symbol','ensembl_gene_id','gene_biotype'), 
                     filters='mgi_symbol',values=rownames(genes_per_class), mart=ensembl_mouse)
id_lengths <- getBM(attributes=c('mgi_symbol','transcript_length'), filters='mgi_symbol',
                    values=rownames(genes_per_class),
                    mart=ensembl_mouse)

## time for some sexy dplyr
by_transcript <- dplyr::group_by(id_lengths, mgi_symbol)
gene_lengths <- dplyr::summarise(by_transcript, length=sum(transcript_length))

ids <- dplyr::left_join(ids, gene_lengths)

## found_ensembl_id_for <- gene_names %in% ensembl_ids$mgi_symbol
genes_per_class <- genes_per_class[ids$mgi_symbol, ]
rownames(genes_per_class) <- ids$ensembl_gene_id
names(genes_per_class) <- 1:n_cuts

enriched_terms <- apply(genes_per_class, 2, function(gene_set) {
  pwf <- nullp(gene_set, 'mm10', 'knownGene', bias.data=ids$length, plot.fit = FALSE)
  go <- goseq(pwf, 'mm10','ensGene', test.cats='GO:BP')
  go$log_qval <- log10(p.adjust(go$over_represented_pvalue, method='BH'))
  go <- dplyr::filter(go, log_qval < log10(0.01))
  go <- dplyr::select(go, category, log_qval, term)
  names(go) <- c('Category','log10 q-value','Term')
  return(go)
  })
#reduced <- lapply(enriched_terms, head, 4)
```

Now print the terms:

```{r print-table, results='asis', cache=TRUE}
# for(i in 1:n_cuts) {
#   print(kable(reduced[[i]], caption = paste('GO terms for cluster', i)))
# }
print(enriched_terms)
```

## BP to AT2 transition

```{r ps-2, cache=TRUE, fig.align='center'}
sce_bp_at2 <- sce[, pData(sce)$cluster %in% c(1,2) & pData(sce)$component_1 < -0.045]
sce_bp_at2 <- fit_pseudotime(sce_bp_at2)
plot_embedding(sce_bp_at2)
```


```{r remove-zero-var2, cache=TRUE}
gene <- 'Fabp5'
plot_in_pseudotime( sce_bp_at2[gene,])

## Remove genes expressed in less than 20% of cells
n_cells_expressed <- rowSums(isExprs(sce_bp_at2))
keep_gene <- n_cells_expressed > 0.2 * dim(sce_bp_at2)[2]
sce_bp_at2 <- sce_bp_at2[keep_gene,]
print(sce_bp_at2)
```

We can also fit a pseudotime cubic smoothing spline regression to `Fabp5`:

```{r plot-fap2, cache=TRUE, fig.align='center', fig.width=5.5, fig.height=3.5}
model <- fit_pseudotime_model(sce_bp_at2, gene)
null_model <- fit_null_model(sce_bp_at2,  gene)
p_val <- compare_models(model, null_model)
plot_pseudotime_model(sce_bp_at2[gene,], model) + ggtitle('Fabp5 expression in pseudotime')
print(paste('P-value: ', p_val))
```

We can then perform the same tests across all genes:

```{r vary-sig-at2, cache=TRUE, message=FALSE}
sce_bp_at2@lowerDetectionLimit <- 0
diff_gene_test <- pseudotime_test(sce_bp_at2, n_cores = 2)

```

Plot the p-values:

```{r plot-pval2, fig.align='center', cache=TRUE, fig.width=5, fig.height=3.5, message=FALSE}
## correct differential gene test
diff_gene_test <- dplyr::filter(diff_gene_test, p_val < 1)
diff_gene_test$q_val <- p.adjust(diff_gene_test$p_val, method='BH')
qplot(diff_gene_test$p_val, binwidth = 0.01) + theme_bw() + xlab('p-value') 
qplot(diff_gene_test$q_val, binwidth = 0.01) + theme_bw() + xlab('corrected p-value')
alpha <- 0.01
sig_genes <- diff_gene_test$gene[diff_gene_test$q_val < alpha]
sce_sig <- sce_bp_at2[sig_genes,]

```

```{r plot-at2, fig.align='center', fig.height=9, fig.width=9, cache=TRUE}
plot_pseudotime_model(sce_sig)
```

Plot correlations of genes across pseudotime:
```{r plot-corr2, fig.align='center', fig.width=9, fig.height=9, message=FALSE}
pe <- predicted_expression(sce_sig)
```

Look at directionality of genes by hierarchical clustering:
```{r corr-clust2, fig.align='center', cache=TRUE, fig.width=9}
pcor <- cor(pe)
dist_cor <- 1 - pcor / 2 
hc <- hclust(as.dist(dist_cor))
plot(hc)
```


Finally plot genes going up or down in pseudotime:
```{r gene-up2, fig.align='center', cache=TRUE, fig.width=10, fig.height=8}
n_cuts <- 3
gene_classes <- cutree(hc, n_cuts)
      
df_gene <- data.frame(gene=colnames(pe), class=gene_classes)

pe <- data.frame(scale(pe)) ## scaled pst-by-gene
pe$pseudotime <- pseudotime(sce_sig)
## save(pe, df_gene, file='~/pe.Rdata')

pe_melted <- melt(pe, id.vars='pseudotime', value.name='expression', variable.name='gene')
pe_melted <- inner_join(pe_melted, df_gene)

## we want to plot the mean expression rather than all of it (messy)
gp_groups <- group_by(pe_melted, class, pseudotime)
mean_expr_per_group <- dplyr::summarise(gp_groups, mean_expr = mean(expression))
pe_melted <- inner_join(pe_melted, mean_expr_per_group)
## pe_melted <- arrange(pe_melted, gene, pseudotime)

ggplot(pe_melted) + geom_line(aes(x=pseudotime, y=mean_expr), color='red') +
  facet_wrap(~ class) + stat_density2d(aes(x=pseudotime, y=expression), n=150) +
  theme_bw() + ylab('Expression')

```

Now look at enriched GO terms for each class:

```{r enrich-go-2, cache=TRUE, message=FALSE, warning=FALSE}
gene_names <- df_gene$gene

genes_per_class <- sapply(1:n_cuts, function(i) 1 * (df_gene$class == i))
rownames(genes_per_class) <- gene_names
# all_other_genes <- setdiff(featureNames(sce_bp_at1), gene_names)
# zero_matrix <- matrix(0, nrow=length(all_other_genes), ncol=n_cuts, dimnames=list(all_other_genes))
# genes_per_class <- rbind(genes_per_class, zero_matrix)
genes_per_class <- as.data.frame(genes_per_class)

ensembl_mouse <- useMart("ensembl",dataset="mmusculus_gene_ensembl")
ids <- getBM(attributes=c('mgi_symbol','ensembl_gene_id','gene_biotype'), 
                     filters='mgi_symbol',values=rownames(genes_per_class), mart=ensembl_mouse)
id_lengths <- getBM(attributes=c('mgi_symbol','transcript_length'), filters='mgi_symbol',
                    values=rownames(genes_per_class),
                    mart=ensembl_mouse)

## time for some sexy dplyr
by_transcript <- dplyr::group_by(id_lengths, mgi_symbol)
gene_lengths <- dplyr::summarise(by_transcript, length=sum(transcript_length))

ids <- dplyr::left_join(ids, gene_lengths)

## found_ensembl_id_for <- gene_names %in% ensembl_ids$mgi_symbol
genes_per_class <- genes_per_class[ids$mgi_symbol, ]
rownames(genes_per_class) <- ids$ensembl_gene_id
names(genes_per_class) <- 1:n_cuts

enriched_terms <- apply(genes_per_class, 2, function(gene_set) {
  pwf <- nullp(gene_set, 'mm10', 'knownGene', bias.data=ids$length, plot.fit = FALSE)
  go <- goseq(pwf, 'mm10','ensGene')#, test.cats='GO:BP')
  go$log_qval <- log10(p.adjust(go$over_represented_pvalue, method='BH'))
  go <- dplyr::filter(go, log_qval < log10(0.01))
  go <- dplyr::select(go, category, log_qval, term)
  names(go) <- c('Category','log10 q-value','Term')
  return(go)
  })

#reduced <- lapply(enriched_terms, head, 4)

```

```{r print-enrich}
print(enriched_terms)

```

